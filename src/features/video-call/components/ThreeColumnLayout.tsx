'use client'

import dynamic from 'next/dynamic'
import React, { useEffect, useRef } from 'react'
import type { Publisher } from 'openvidu-browser'

import { useEnvironmentInfo } from '../hooks'
import {
  useSessionStatus,
  useError,
  useLoading,
  useVideoCallActions,
  usePublisher,
} from '../store'
import ErrorScreen from './ErrorScreen'
import LoadingScreen from './LoadingScreen'
import LocalVideoPanel from './LocalVideoPanel'
import ModifiedControlsBar from './ModifiedControlsBar'
import ModifiedSidebar from './ModifiedSidebar'
import RemoteVideoPanel from './RemoteVideoPanel'
import type { SafeAny as _SafeAny } from '../types/common.types'
import { isRecord } from '../types/guards.types'
import { globalSessionManager } from '../utils/sessionManager'

interface ThreeColumnLayoutProps {
  username?: string
  sessionName?: string
  reservationId?: number
  onLeaveSession?: () => void
}

function ThreeColumnLayoutInner({
  username,
  sessionName,
  reservationId,
  onLeaveSession,
}: ThreeColumnLayoutProps) {
  const sessionStatus = useSessionStatus()
  const error = useError()
  const loading = useLoading()
  const publisher = usePublisher()
  const actions = useVideoCallActions()

  // 환경 정보 로깅 및 장치 정보 확인
  const environmentInfo = useEnvironmentInfo()

  // 세션 연결 및 Publisher 생성 (StrictMode-safe)
  const initializingRef = useRef(false)
  const sessionKeyRef = useRef<string | null>(null)

  useEffect(() => {
    // React StrictMode에서 중복 실행 방지 - 전역 세션 관리자 사용
    if (initializingRef.current) {
      return
    }
    initializingRef.current = true

    // cleanup timeout 취소 (컴포넌트가 다시 마운트된 경우)
    globalSessionManager.cancelCleanup()
    // Case 1: reservationId가 있는 경우 (정규 API 사용)
    if (reservationId) {
      const sessionKey = `reservation-${reservationId}`
      sessionKeyRef.current = sessionKey

      if (sessionStatus !== 'idle') {
        console.log(
          '⚠️ 세션이 이미 연결 중이거나 연결됨, 초기화 생략',
        )
        initializingRef.current = false
        return
      }

      const initializeWithReservation = async () => {
        try {
          console.log(
            '🚀 예약 기반 화상통화 세션 초기화 시작',
            `reservationId:${reservationId}`,
          )

          // 1. API를 통한 Quick Join (정규 API)
          const { videoCallApiService } = await import(
            '../services/VideoCallApiService'
          )

          const apiResponse = await videoCallApiService.quickJoin({
            username: 'User',
            sessionName: sessionKey,
            reservationId,
          })

          console.log(
            '✅ API Quick Join 완료',
            `${apiResponse.username}@${apiResponse.sessionId}`,
          )

          // 2. 세션 연결 (API에서 받은 정보 사용)
          await actions.connect(
            {
              id: apiResponse.sessionId,
              name: apiResponse.sessionName,
              token: apiResponse.token,
              serverUrl: apiResponse.openviduServerUrl,
            },
            apiResponse.username,
          )

          console.log('✅ 세션 연결 완료')

          // 3. OpenViduClient에서 자동 생성된 Publisher 확인 및 Store 저장
          let hasAutoGeneratedPublisher = false
          try {
            const { openViduClient } = await import(
              '../services/OpenViduClient'
            )

            // OpenViduClient의 내부 publisher 접근 (private이므로 reflection 필요)
            const clientPublisher = (
              openViduClient as unknown as { publisher?: Publisher }
            ).publisher
            if (clientPublisher) {
              actions.setPublisher(clientPublisher)
              hasAutoGeneratedPublisher = true
              console.log(
                '✅ 자동 생성된 Publisher를 Store에 저장 완료',
                {
                  streamId: clientPublisher.stream?.streamId,
                  hasAudio: clientPublisher.stream?.hasAudio,
                  hasVideo: clientPublisher.stream?.hasVideo,
                },
              )
            } else {
              console.log(
                '⚠️ OpenViduClient에서 Publisher가 자동 생성되지 않음',
              )
            }
          } catch (error) {
            console.error('❌ Publisher Store 저장 실패:', error)
          }

          // 4. Publisher 수동 생성 (자동 생성되지 않은 경우만)
          if (!hasAutoGeneratedPublisher) {
            try {
              const hasVideoDevice =
                environmentInfo?.hasVideoDevice ?? true
              console.log(
                `📹 비디오 장치 확인: ${hasVideoDevice ? '있음' : '없음 - 오디오 전용 모드'}`,
              )

              await actions.createPublisher({
                publishAudio: true,
                publishVideo: hasVideoDevice,
                resolution:
                  apiResponse.configInfo?.defaultResolution ||
                  '1280x720',
                frameRate:
                  apiResponse.configInfo?.defaultFrameRate || 30,
              })
              console.log('✅ Publisher 수동 생성 완료')
            } catch (error) {
              console.error('❌ Publisher 수동 생성 실패:', error)
            }
          }

          // 5. 로컬 참가자 추가
          try {
            const hasVideoDevice =
              environmentInfo?.hasVideoDevice ?? true

            actions.addParticipant({
              id: `local-${Date.now()}`,
              connectionId: `local-connection-${Date.now()}`,
              nickname: apiResponse.username,
              isLocal: true,
              streams: {},
              audioLevel: 0,
              speaking: false,
              audioEnabled: true,
              videoEnabled: hasVideoDevice,
              isScreenSharing: false,
              joinedAt: new Date(),
            })

            console.log('✅ 로컬 참가자 추가 완료')
          } catch (error) {
            console.error('❌ 로컬 참가자 추가 실패:', error)
          }
        } catch (error) {
          console.error('❌ 예약 기반 세션 초기화 실패:', error)
          throw error
        } finally {
          initializingRef.current = false
        }
      }

      // 전역 세션 관리자를 통한 초기화
      globalSessionManager
        .initializeSession(sessionKey, initializeWithReservation)
        .catch((error) => {
          console.error('❌ 전역 세션 관리자 초기화 실패:', error)
        })
    }

    // Case 2: username과 sessionName이 있는 경우 (테스트룸)
    else if (username && sessionName) {
      const sessionKey = `testroom-${username}-${sessionName}`
      sessionKeyRef.current = sessionKey

      if (sessionStatus !== 'idle') {
        console.log(
          '⚠️ 세션이 이미 연결 중이거나 연결됨, 초기화 생략',
        )
        initializingRef.current = false
        return
      }

      const initializeSession = async () => {
        try {
          console.log(
            '🚀 화상통화 세션 초기화 시작',
            `${username}@${sessionName}`,
          )

          // 1. 세션 연결
          await actions.connect(
            {
              id: sessionName,
              name: sessionName,
              token: '',
              serverUrl:
                process.env.NEXT_PUBLIC_OPENVIDU_SERVER_URL ||
                'https://demos.openvidu.io',
            },
            username,
          )

          console.log('✅ 세션 연결 완료')

          // 2. OpenViduClient에서 자동 생성된 Publisher 확인 및 Store 저장
          let hasAutoGeneratedPublisher = false
          try {
            const { openViduClient } = await import(
              '../services/OpenViduClient'
            )

            // OpenViduClient의 내부 publisher 접근 (private이므로 reflection 필요)
            const clientPublisher = (
              openViduClient as unknown as { publisher?: Publisher }
            ).publisher
            if (clientPublisher) {
              actions.setPublisher(clientPublisher)
              hasAutoGeneratedPublisher = true
              console.log(
                '✅ 자동 생성된 Publisher를 Store에 저장 완료',
                {
                  streamId: clientPublisher.stream?.streamId,
                  hasAudio: clientPublisher.stream?.hasAudio,
                  hasVideo: clientPublisher.stream?.hasVideo,
                },
              )
            } else {
              console.log(
                '⚠️ OpenViduClient에서 Publisher가 자동 생성되지 않음',
              )
            }
          } catch (error) {
            console.error('❌ Publisher Store 저장 실패:', error)
          }

          // 3. Publisher 수동 생성 (자동 생성되지 않은 경우만)
          if (!hasAutoGeneratedPublisher) {
            try {
              const hasVideoDevice =
                environmentInfo?.hasVideoDevice ?? true
              console.log(
                `📹 비디오 장치 확인: ${hasVideoDevice ? '있음' : '없음 - 오디오 전용 모드'}`,
              )

              await actions.createPublisher({
                publishAudio: true,
                publishVideo: hasVideoDevice,
                resolution: '1280x720',
                frameRate: 30,
              })
              console.log('✅ Publisher 수동 생성 완료')
            } catch (error) {
              console.error('❌ Publisher 수동 생성 실패:', error)
            }
          }

          // 4. 로컬 참가자 추가
          try {
            const hasVideoDevice =
              environmentInfo?.hasVideoDevice ?? true

            actions.addParticipant({
              id: `local-${Date.now()}`,
              connectionId: `local-connection-${Date.now()}`,
              nickname: username,
              isLocal: true,
              streams: {},
              audioLevel: 0,
              speaking: false,
              audioEnabled: true,
              videoEnabled: hasVideoDevice,
              isScreenSharing: false,
              joinedAt: new Date(),
            })

            console.log('✅ 로컬 참가자 추가 완료')
          } catch (error) {
            console.error('❌ 로컬 참가자 추가 실패:', error)
          }
        } catch (error) {
          console.error('❌ 세션 초기화 실패:', error)
          throw error
        } finally {
          initializingRef.current = false
        }
      }

      // 전역 세션 관리자를 통한 초기화
      globalSessionManager
        .initializeSession(sessionKey, initializeSession)
        .catch((error) => {
          console.error('❌ 전역 세션 관리자 초기화 실패:', error)
        })
    }

    // Case 3: 필수 파라미터 누락
    else {
      console.warn(
        'username과 sessionName 또는 reservationId가 필요합니다',
        {
          username,
          sessionName,
          reservationId,
        },
      )
      initializingRef.current = false
    }

    // cleanup 함수 반환 (StrictMode-safe) - 전역 세션 관리자 사용
    return () => {
      if (sessionKeyRef.current) {
        const sessionKey = sessionKeyRef.current
        globalSessionManager.scheduleCleanup(
          sessionKey,
          async () => {
            console.log('🧹 지연된 세션 cleanup 실행', sessionKey)
            if (actions.getState().status === 'connected') {
              try {
                await actions.destroyPublisher?.()
                await actions.disconnect()
                console.log('✅ 세션 cleanup 완료', sessionKey)
              } catch (error) {
                console.error('❌ 세션 cleanup 실패:', error)
              }
            }
          },
          500, // 500ms 지연으로 StrictMode cleanup과 실제 cleanup 구분
        )
      }

      initializingRef.current = false
    }
  }, [
    username,
    sessionName,
    reservationId,
    sessionStatus,
    actions,
    environmentInfo?.hasVideoDevice,
  ])

  // Publisher 생성 완료 시 로컬 참가자 ID 설정
  useEffect(() => {
    if (publisher && sessionStatus === 'connected') {
      const state = actions.getState?.()
      if (isRecord(state) && state.participants instanceof Map) {
        const localParticipants = Array.from(
          (
            state.participants as unknown as Map<
              string,
              Record<string, unknown>
            >
          ).values(),
        ).filter((p: Record<string, unknown>) => p.isLocal === true)

        if (
          localParticipants.length > 0 &&
          isRecord(localParticipants[0]) &&
          localParticipants[0].id
        ) {
          // 첫 번째 로컬 참가자를 현재 localParticipantId로 설정
          actions.setLocalParticipantId?.(
            String(localParticipants[0].id),
          )
        }
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [publisher, sessionStatus]) // actions 의도적으로 제외

  // 로딩 상태 표시
  if (loading || sessionStatus === 'connecting') {
    return <LoadingScreen />
  }

  // 에러 상태 표시
  if (error) {
    return <ErrorScreen error={error} />
  }

  return (
    <div className="grid h-full w-full grid-cols-[1fr_1fr_360px] overflow-hidden bg-[var(--color-gray-900)]">
      {/* 좌측 패널 - 상대방 비디오 */}
      <div className="relative min-h-0 min-w-0 overflow-hidden">
        <RemoteVideoPanel />
      </div>

      {/* 중앙 패널 - 내 비디오 */}
      <div className="relative min-h-0 min-w-0 overflow-hidden">
        <LocalVideoPanel />
      </div>

      {/* 우측 사이드바 - 2개 탭 (채팅/공유된 자료) */}
      <div className="min-h-0 min-w-0 overflow-hidden">
        <ModifiedSidebar />
      </div>

      {/* 하단 컨트롤바 (3열 전체에 오버레이) */}
      <ModifiedControlsBar onLeaveSession={onLeaveSession} />
    </div>
  )
}

// SSR 방지를 위한 dynamic export (WebRTC는 브라우저 전용)
const ThreeColumnLayout = dynamic(
  () => Promise.resolve(ThreeColumnLayoutInner),
  {
    ssr: false,
    loading: () => <LoadingScreen message="비디오 통화 준비 중..." />,
  },
)

export default ThreeColumnLayout
